///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
use std::fs::{ self, File };
use nitrogen::fmt_path;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(serde::Deserialize)]
struct Pool {
	common: Option<String>, // common dir
	files: Vec<String>,
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
fn main() -> Result<(), Box<dyn std::error::Error>> {
	let Some(path) =  std::env::args().nth(1) else { Err("No Argument")? };
	let Pool { common, files } = toml::from_str(&fs::read_to_string(fmt_path(path))?)?;
	let common = common.map_or_else(String::new, |directory| directory + std::path::MAIN_SEPARATOR_STR);
	let mut files: Vec<File> = files
		.into_iter()
		.filter_map(|file| File::open(fmt_path(format!("{common}{file}"))).ok())
		.collect();
	let mut generator = fastrand::Rng::new();
	while !files.is_empty() {
		rodio::OutputStream::try_default()?
			.1
			.play_once(files.remove(generator.usize(0..files.len())))?
			.sleep_until_end();
	}
	Ok(())
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
